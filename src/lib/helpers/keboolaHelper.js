'use strict';
import fs from 'fs';
import csv from 'fast-csv';
import path from 'path';
import nconf from 'nconf';
import moment from 'moment';
import isThere from 'is-there';
import jsonfile from 'jsonfile';
import {
  isEmpty,
  isArray,
  isUndefined
} from 'lodash';
import {
  EVENT_ERROR,
  EVENT_FINISH,
  IS_INCREMENTAL,
  DEFAULT_DATASETS,
  DEFAULT_DATE_MASK,
  DEFAULT_START_DATE,
  CONVERT_EPOCH_TO_DATE
} from '../constants';

/**
 * This function read the configuration generated by Keboola Connection.
 * If everything is all right, a valid object is returned.
 * Otherwise, the extractor terminates.
 */
export function getConfig(configPath) {
  const config = nconf.env();
  if (isThere(configPath)) {
    config.file(configPath);
    return config;
  } else {
    console.error('No configuration specified!');
    process.exit(1);
  }
}

/**
 * This function check the input configuration specified in KBC.
 * Check whether the required fields are provided.
 * Prepare simple output that is going to be used in later phases.
 */
export function parseConfiguration(configObject) {
  return new Promise((resolve, reject) => {
    // The most important parameters to read are #apiKey and #apiSecret (both stored in an encrypted form).
    const apiKey = configObject.get('parameters:#apiKey');
    const apiSecret = configObject.get('parameters:#apiSecret');
    if (isUndefined(apiKey) || isUndefined(apiSecret)) {
      reject('Missing parameters apiKey or apiSecret! Check out the documentation for more details!');
    }
    // Another parameter is related to settings of the conversion for the date information.
    // If not specified, default (true) value is set and original timestamps are kept.
    const convertTimestampToDate = !isUndefined(configObject.get('parameters:convertTimestampToDate'))
      ? configObject.get('parameters:convertTimestampToDate')
      : CONVERT_EPOCH_TO_DATE;
    // Another important step is to set the date range properly.
    const maximalDate = moment.utc().subtract(1, "days").format(DEFAULT_DATE_MASK);
    const startDate = isUndefined(configObject.get('parameters:startDate')) || isEmpty(configObject.get('parameters:startDate'))
      ? DEFAULT_START_DATE
      : configObject.get('parameters:startDate');
    const endDate = isUndefined(configObject.get('parameters:endDate')) || isEmpty(configObject.get('parameters:endDate'))
      ? maximalDate
      : configObject.get('parameters:endDate');
    // Verify whether the format of the startDate and endDate is correct.
    if (moment(startDate)._f !== DEFAULT_DATE_MASK) {
      reject(`Invalid date mask set for parameter 'startDate'. Please set the value to ${DEFAULT_DATE_MASK}`);
    }
    if (moment(endDate)._f !== DEFAULT_DATE_MASK) {
      reject(`Invalid date mask set for parameter 'endDate'. Please set the value to ${DEFAULT_DATE_MASK}`);
    }
    // Verify whether an input date are inserted in proper order.
    if (moment(endDate, DEFAULT_DATE_MASK).diff(moment(startDate, DEFAULT_DATE_MASK)) <= 0) {
      reject(`Parameter endDate ${endDate} is older than or equal to startDate ${startDate}! Please check out the documentation for more information.`);
    }
    // Verify whether endDate is not older than today() - 1.
    if (moment(endDate, DEFAULT_DATE_MASK).diff(maximalDate) > 0) {
      reject(`Parameter endDate ${endDate} is bigger than maximal allowed date value ${maximalDate}! Please check out the documentation for more information.`);
    }
    // All files are going to be uploaded as full loads. For this case we are going to set a default value.
    const incremental = IS_INCREMENTAL;
    // If everything is all right, we can prepare the params object and pass all important parameters into the main execution.
    const sailthruCampaignParams = Object.assign({}, DEFAULT_DATASETS, {
      start_date: startDate,
      end_date: endDate
    });
    // And the final object is here.
    resolve({
      apiKey,
      endDate,
      startDate,
      apiSecret,
      incremental,
      sailthruCampaignParams,
      convertTimestampToDate
    });
  });
}

/**
 * This function just stores data to selected destination.
 * Data is appending to a file, the first one needs to have a header.
 */
export function createOutputFile(fileName, inputData) {
  return new Promise((resolve, reject) => {
    const data = !isArray(inputData)
      ? [ inputData ]
      : inputData;
    const headers = !isThere(fileName);
    const includeEndRowDelimiter = true;
    csv
      .writeToStream(fs.createWriteStream(fileName, {'flags': 'a'}), data, { headers, includeEndRowDelimiter })
      .on(EVENT_ERROR, () => reject('Problem with writing data into output!'))
      .on(EVENT_FINISH, () => resolve(fileName));
  });
}

/**
 * This function simply create a manifest file related to the output data
 */
export function createManifestFile(fileName, data) {
  return new Promise((resolve, reject) => {
    jsonfile.writeFile(fileName, data, {}, (error) => {
      if (error) {
        reject(error);
      } else {
        resolve('Manifest created!');
      }
    });
  });
}
